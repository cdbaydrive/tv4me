<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>IPTV Playlist Viewer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.0.4/pako.min.js"></script>
  <style>
    .star {
      cursor: pointer;
      font-size: 1.2rem;
    }
    #playlistScroll {
      height: calc(100vh - 340px);
      overflow-y: auto;
      scroll-behavior: smooth;
    }
    .nav-link {
      @apply px-4 py-2 font-medium cursor-pointer rounded hover:bg-blue-100;
    }
    .thumbnail-container {
      position: relative;
      overflow: hidden;
    }
    .thumbnail-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      opacity: 0;
      transition: opacity 0.3s;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 1rem;
      overflow-y: auto;
    }
    .thumbnail-container:hover .thumbnail-overlay {
      opacity: 1;
    }
    .overlay-content {
      width: 100%;
      text-align: center;
    }
    .overlay-content button {
      @apply text-xs px-2 py-1 rounded mx-1;
    }
    #epgGrid {
      display: grid;
      grid-template-columns: 200px 50px 300px;
      width: 100%;
      max-width: calc(100vw - 2.5rem);
      overflow-x: auto;
      overflow-y: auto;
      max-height: calc(100vh - 400px);
      white-space: nowrap;
    }
    .epg-channel {
      @apply bg-gray-200 p-2 border-r border-b text-sm font-semibold sticky left-0 z-10;
      min-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .epg-program {
      @apply bg-blue-100 p-1 border-r border-b text-xs;
      min-width: 300px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .epg-program:hover {
      @apply bg-blue-200;
    }
    .epg-header {
      @apply bg-gray-300 p-2 border-r border-b text-sm font-semibold text-center sticky top-0 z-10;
    }
    .epg-program button {
      @apply text-xs px-2 py-1 rounded cursor-pointer;
    }
    .epg-program-title {
      @apply flex-1 truncate text-blue-600 text-sm mr-2;
    }
  </style>
</head>
<body class="bg-gray-100 min-h-screen p-4">
  <div class="w-full bg-white rounded-2xl shadow-md p-6">
    <div class="flex justify-center gap-6 mb-4 text-blue-600 text-sm">
      <span class="nav-link" onclick="loadTMDB('movie')">Movies</span>
      <span class="nav-link" onclick="loadTMDB('tv')">Series</span>
      <span class="nav-link" onclick="loadEPG()">EPG</span>
    </div>

    <h1 class="text-2xl font-bold mb-2 text-center">IPTV Playlist Viewer</h1>
    <p class="text-gray-500 text-xs text-center mb-4">Version 1.3.2</p>

    <div id="tmdbContent" class="hidden mb-6">
      <h2 class="text-xl font-semibold mb-2" id="tmdbTitle"></h2>
      <div id="tmdbSections" class="grid gap-4"></div>
      <div class="text-center mt-4">
        <button class="text-blue-500 underline" onclick="closeTMDB()">Close</button>
      </div>
    </div>

    <div class="flex flex-wrap gap-2 mb-2">
      <input type="text" id="m3uUrl" placeholder="Enter M3U URL" class="flex-grow border p-2 rounded">
      <select id="epgSource" class="flex-grow border p-2 rounded">
        <option value="">Select EPG Source</option>
        <option value="https://epg.pw/xmltv/epg_FR.xml">France - epg.pw</option>
        <option value="https://raw.githubusercontent.com/dp247/Freeview-EPG/master/epg.xml">UK - Freeview</option>
        <option value="https://raw.githubusercontent.com/acidjesuz/EPGTalk/main/USA.xml">USA - EPGTalk</option>
      </select>
      <button class="bg-green-600 text-white px-4 py-2 rounded" onclick="fetchM3U()">Fetch Playlist</button>
      <button class="bg-blue-600 text-white px-4 py-2 rounded" onclick="fetchEPG()">Fetch EPG</button>
    </div>

    <p id="fetchStatus" class="text-sm text-gray-600 mb-4 h-5"></p>

    <div class="flex flex-wrap gap-2 items-center mb-4">
      <button class="bg-orange-500 text-white px-4 py-2 rounded" onclick="exportPlaylistAsM3U()">Download Playlist</button>
      <label class="cursor-pointer bg-blue-500 text-white px-4 py-2 rounded">
        Upload Playlist
        <input type="file" id="uploadM3U" accept=".m3u" class="hidden" onchange="handleM3UUpload(event)">
      </label>
      <label class="cursor-pointer bg-blue-500 text-white px-4 py-2 rounded">
        Upload EPG
        <input type="file" id="uploadEPG" accept=".xml,.xml.gz" class="hidden" onchange="fetchEPG()">
      </label>
    </div>

    <div class="mb-4">
      <input type="text" id="searchInput" placeholder="Search channels..." class="border p-2 w-full rounded">
    </div>

    <div class="flex flex-wrap items-center gap-2 mb-4">
      <div class="flex flex-grow gap-2 w-full">
        <select id="languageFilter" class="p-2 border rounded w-1/4">
          <option value="">Filter by Language</option>
        </select>
        <select id="qualityFilter" class="p-2 border rounded w-1/4">
          <option value="">Filter by Quality</option>
        </select>
        <select id="yearFilter" class="p-2 border rounded w-1/4">
          <option value="">Filter by Year</option>
        </select>
        <select id="typeFilter" class="p-2 border rounded w-1/4">
          <option value="">Filter by Type</option>
          <option value="movie">Movie</option>
          <option value="series">Series</option>
          <option value="channel">TV Channel</option>
        </select>
      </div>
      <button id="toggleFavoritesBtn" class="ml-auto bg-yellow-400 text-black px-4 py-2 rounded">Favorites</button>
    </div>

    <div id="playlistScroll" class="bg-gray-50 border rounded p-2">
      <div id="playlistDisplay" class="space-y-2"></div>
    </div>
  </div>

  <script>
    let currentPlaylist = [];
    let favorites = JSON.parse(localStorage.getItem('favorites') || '[]');
    let showingFavorites = false;
    let filteredPlaylist = [];
    let rowHeight = 32;
    let visibleCount = 100;
    let epgData = { channels: [], programs: [] };

    const urlInput = document.getElementById('m3uUrl');
    const epgSourceSelect = document.getElementById('epgSource');
    const statusText = document.getElementById('fetchStatus');

    window.addEventListener('DOMContentLoaded', () => {
      const savedM3UUrl = localStorage.getItem('lastM3UUrl');
      const savedEPGSource = localStorage.getItem('lastEPGSource');
      if (savedM3UUrl) urlInput.value = savedM3UUrl;
      if (savedEPGSource) epgSourceSelect.value = savedEPGSource;
    });

    function setStatus(message, isError = false) {
      statusText.textContent = message;
      statusText.className = isError
        ? 'text-sm text-red-600 mb-4 h-5'
        : 'text-sm text-gray-600 mb-4 h-5';
    }

    function fetchM3U() {
      const url = urlInput.value.trim();
      if (!url) return alert('Please enter a M3U URL.');

      setStatus('Connecting to server...');
      localStorage.setItem('lastM3UUrl', url);

      fetch(url)
        .then(res => {
          if (!res.ok) throw new Error('Server returned an error.');
          setStatus('Connected. Fetching playlist...');
          return res.text();
        })
        .then(data => {
          parseM3U(data);
          setStatus('Playlist loaded successfully.');
        })
        .catch(err => {
          console.error('Fetch error:', err);
          setStatus('Failed to fetch playlist.', true);
        });
    }

    document.getElementById('searchInput').addEventListener('input', debounce(applyFilters, 300));
    document.getElementById('languageFilter').addEventListener('change', applyFilters);
    document.getElementById('qualityFilter').addEventListener('change', applyFilters);
    document.getElementById('yearFilter').addEventListener('change', applyFilters);
    document.getElementById('typeFilter').addEventListener('change', applyFilters);
    document.getElementById('toggleFavoritesBtn').addEventListener('click', () => {
      showingFavorites = !showingFavorites;
      document.getElementById('toggleFavoritesBtn').textContent = showingFavorites ? 'Back to Playlist' : 'Favorites';
      applyFilters();
    });
    document.getElementById('playlistScroll').addEventListener('scroll', () => {
      requestAnimationFrame(renderVisibleRows);
    });

    function parseM3U(text) {
      const lines = text.split('\n');
      const channels = [];
      let current = {};
      for (let line of lines) {
        line = line.trim();
        if (line.startsWith('#EXTINF')) {
          const nameMatch = line.match(/,(.*)/);
          const groupMatch = line.match(/group-title="(.*?)"/i);
          const yearMatch = line.match(/year="(\d{4})"/i) || line.match(/(?:^|\D)((?:19|20)\d{2})(?:\D|$)/);
          const name = nameMatch ? nameMatch[1] : 'Unknown';
          const type = inferType(name);

          current = {
            name,
            group: groupMatch ? groupMatch[1] : 'Other',
            year: yearMatch ? yearMatch[1] : '',
            type
          };
        } else if (line && !line.startsWith('#')) {
          current.url = line;
          channels.push({ ...current });
        }
      }
      currentPlaylist = channels;
      populateFilters(channels);
      applyFilters();
    }

    function inferType(name) {
      if (/S\d{1,2}\s?E\d{1,2}/i.test(name) || /Season\s?\d{1,2}/i.test(name) || /Episode\s?\d{1,2}/i.test(name) || /\b(Part\s?\d{1,2}|[Ss]\d{1,2})/i.test(name)) {
        return 'series';
      }
      if (/(19|20)\d{2}/.test(name)) return 'movie';
      return 'channel';
    }

    function populateFilters(channels) {
      const languageSelect = document.getElementById('languageFilter');
      const qualitySelect = document.getElementById('qualityFilter');

      const languages = new Set();
      const qualities = new Set();

      channels.forEach(ch => {
        const name = ch.name;
        const langMatch = name.match(/^([A-Z]{2})[:\s-]/);
        const lang = langMatch ? langMatch[1] : 'Other';
        languages.add(lang);

        if (/UHD|4K/i.test(name)) qualities.add('UHD');
        else if (/FHD|1080p/i.test(name)) qualities.add('FHD');
        else if (/HD|720p/i.test(name)) qualities.add('HD');
        else if (/SD|480p/i.test(name)) qualities.add('SD');
        else qualities.add('Unknown');
      });

      const sortedLangs = Array.from(languages).sort((a, b) => {
        if (a === 'FR') return -1;
        if (b === 'FR') return 1;
        if (a === 'EN') return -1;
        if (b === 'EN') return 1;
        return a.localeCompare(b);
      });

      languageSelect.innerHTML = '<option value="">Filter by Language</option>' + sortedLangs.map(l => `<option value="${l}">${l}</option>`).join('');
      qualitySelect.innerHTML = '<option value="">Filter by Quality</option>' + Array.from(qualities).sort().map(q => `<option value="${q}">${q}</option>`).join('');
    }

    function updateYearFilterOptions(channels) {
      const yearSelect = document.getElementById('yearFilter');
      const years = new Set();
      channels.forEach(ch => {
        if (ch.year && /^\d{4}$/.test(ch.year)) years.add(ch.year);
      });
      const sortedYears = Array.from(years).sort((a, b) => b - a);
      yearSelect.innerHTML = '<option value="">Filter by Year</option>' + sortedYears.map(y => `<option value="${y}">${y}</option>`).join('');
    }

    function applyFilters() {
      const search = document.getElementById('searchInput').value.toLowerCase();
      const lang = document.getElementById('languageFilter').value;
      const quality = document.getElementById('qualityFilter').value;
      const year = document.getElementById('yearFilter').value;
      const type = document.getElementById('typeFilter').value;

      filteredPlaylist = currentPlaylist.filter(ch => {
        const matchesSearch = ch.name.toLowerCase().includes(search);
        const matchesLang = !lang || ch.name.startsWith(lang);
        const matchesQuality = !quality || (
          (quality === 'UHD' && /UHD|4K/i.test(ch.name)) ||
          (quality === 'FHD' && /FHD|1080p/i.test(ch.name)) ||
          (quality === 'HD' && /HD|720p/i.test(ch.name)) ||
          (quality === 'SD' && /SD|480p/i.test(ch.name)) ||
          (quality === 'Unknown' && !/(UHD|4K|FHD|1080p|HD|720p|SD|480p)/i.test(ch.name))
        );
        const matchesYear = !year || ch.year === year;
        const matchesType = !type || ch.type === type;

        return matchesSearch && matchesLang && matchesQuality && matchesYear && matchesType;
      });

      if (showingFavorites) {
        filteredPlaylist = filteredPlaylist.filter(ch => favorites.includes(ch.url));
      }

      updateYearFilterOptions(filteredPlaylist);
      renderVisibleRows();
    }

    function renderVisibleRows() {
      const scrollTop = document.getElementById('playlistScroll').scrollTop;
      const start = Math.max(0, Math.floor(scrollTop / rowHeight) - 5);
      const end = start + visibleCount + 10;

      const display = document.getElementById('playlistDisplay');
      display.innerHTML = '';

      const currentTime = new Date();

      for (let i = start; i < Math.min(end, filteredPlaylist.length); i++) {
        const ch = filteredPlaylist[i];
        const div = document.createElement('div');
        div.className = 'flex justify-between items-center border-b py-1 text-sm';

        let epgProgram = '';
        if (ch.type === 'channel' && epgData.channels.length > 0) {
          const epgChannel = epgData.channels.find(c => fuzzyMatch(c.name, ch.name) >= 0.6 || ch.name.toLowerCase().includes(c.name.toLowerCase()));
          if (epgChannel) {
            const program = epgData.programs.find(p => p.channelId === epgChannel.id && currentTime >= p.start && currentTime < p.end);
            if (program) {
              epgProgram = `<span class="epg-program-title">${program.title.replace(/[\n\r]/g, '').trim()}</span>`;
            }
          }
        }

        const isFavorite = favorites.includes(ch.url);
        div.innerHTML = `
          <span class="truncate flex-1">${ch.name.replace(/[\n\r]/g, '').trim()}</span>
          ${epgProgram}
          <div class="flex items-center gap-2">
            <span class="star" onclick="toggleFavorite('${ch.url}')">${isFavorite ? '★' : '☆'}</span>
            <button onclick="playStream('${ch.url}', '${ch.name.replace(/[\n\r]/g, '')}')" class="text-blue-600 text-xs">Play</button>
            <button onclick="copyToClipboard('${ch.url}')" class="text-green-600 text-xs">Copy</button>
          </div>
        `;
        display.appendChild(div);
      }
    }

    function playStream(url, name) {
      const content = `#EXTM3U\n#EXTINF:-1,${name}\n${url}\n`;
      const blob = new Blob([content], { type: 'audio/x-mpegurl' });
      const downloadUrl = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = downloadUrl;
      a.download = `${name.replace(/[^a-zA-Z0-9]/g, '_')}.m3u`;
      a.click();
      URL.revokeObjectURL(downloadUrl);
    }

    function copyToClipboard(url) {
      navigator.clipboard.writeText(url)
        .then(() => {
          setStatus('URL copied to clipboard.');
          setTimeout(() => setStatus(''), 1500);
        })
        .catch(err => {
          console.error('Clipboard copy failed:', err);
          setStatus('Failed to copy URL.', true);
        });
    }

    function toggleFavorite(url) {
      const idx = favorites.indexOf(url);
      if (idx >= 0) favorites.splice(idx, 1);
      else favorites.push(url);
      localStorage.setItem('favorites', JSON.stringify(favorites));
      applyFilters();
    }

    function handleM3UUpload(event) {
      const file = event.target.files[0];
      if (!file) return alert('No file selected.');

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          parseM3U(e.target.result);
          alert('Playlist loaded successfully!');
        } catch (err) {
          console.error('Parse error:', err);
          alert('Failed to parse uploaded M3U file.');
        }
      };
      reader.readAsText(file);
    }

    function exportPlaylistAsM3U() {
      if (!currentPlaylist || currentPlaylist.length === 0) {
        return alert('No playlist to export.');
      }

      let content = "#EXTM3U\n";
      currentPlaylist.forEach(ch => {
        content += `#EXTINF:-1 group-title="${ch.group}"${ch.year ? ` year="${ch.year}"` : ''},${ch.name}\n${ch.url}\n`;
      });

      const blob = new Blob([content], { type: 'audio/x-mpegurl' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'playlist.m3u';
      a.click();
      URL.revokeObjectURL(url);
    }

    function debounce(fn, delay) {
      let timer;
      return function(...args) {
        clearTimeout(timer);
        timer = setTimeout(() => fn.apply(this, args), delay);
      };
    }

    function fuzzyMatch(str1, str2) {
      const normalize = str => str
        .toLowerCase()
        .replace(/[.,\/#!$%\^&\*;:{}=\-_`~()]/g, '')
        .replace(/\s+/g, ' ')
        .trim();
      
      str1 = normalize(str1);
      str2 = normalize(str2);

      if (str1 === str2) return 1;

      const words1 = str1.split(' ');
      const words2 = str2.split(' ');
      let score = 0;
      let matches = 0;

      for (let w1 of words1) {
        for (let w2 of words2) {
          if (w1 === w2) {
            matches++;
            score += 1;
          } else if (w1.length > 3 && w2.length > 3 && (w1.includes(w2) || w2.includes(w1))) {
            matches++;
            score += 0.5;
          }
        }
      }

      const maxWords = Math.max(words1.length, words2.length);
      return matches > 0 ? score / maxWords : 0;
    }

    function findPlaylistMatches(title, type) {
      const matches = [];
      const threshold = 0.6;
      currentPlaylist.forEach(item => {
        if (item.type === type || (type === 'tv' && item.type === 'series') || (type === 'movie' && item.type === 'movie')) {
          const similarity = fuzzyMatch(title, item.name);
          if (similarity >= threshold || item.name.toLowerCase().includes(title.toLowerCase())) {
            let quality = 'Unknown';
            if (/UHD|4K/i.test(item.name)) quality = 'UHD';
            else if (/FHD|1080p/i.test(item.name)) quality = 'FHD';
            else if (/HD|720p/i.test(item.name)) quality = 'HD';
            else if (/SD|480p/i.test(item.name)) quality = 'SD';
            matches.push({
              name: item.name,
              url: item.url,
              quality: quality,
              year: item.year
            });
          }
        }
      });
      return matches;
    }

    function findMatchingChannel(epgChannelName) {
      const threshold = 0.6;
      for (let item of currentPlaylist) {
        if (item.type === 'channel') {
          const similarity = fuzzyMatch(epgChannelName, item.name);
          if (similarity >= threshold || item.name.toLowerCase().includes(epgChannelName.toLowerCase())) {
            return item;
          }
        }
      }
      return null;
    }

    function fetchEPG() {
      const fileInput = document.getElementById('uploadEPG');
      const file = fileInput.files[0];

      if (file) {
        setStatus('Reading EPG file...');
        const reader = new FileReader();
        reader.onload = function(e) {
          try {
            let xmlText;
            if (file.name.endsWith('.gz')) {
              xmlText = pako.inflate(new Uint8Array(e.target.result), { to: 'string' });
            } else {
              xmlText = e.target.result;
            }
            parseEPG(xmlText);
            setStatus('EPG loaded successfully.');
            fileInput.value = ''; // Clear file input
            applyFilters();
          } catch (err) {
            console.error('EPG file error:', err);
            setStatus('Failed to process EPG file.', true);
          }
        };
        reader.onerror = function() {
          console.error('File read error');
          setStatus('Failed to read EPG file.', true);
        };
        if (file.name.endsWith('.gz')) {
          reader.readAsArrayBuffer(file);
        } else {
          reader.readAsText(file);
        }
      } else {
        const source = epgSourceSelect.value;
        if (!source) return alert('Please select an EPG source or upload an EPG file.');

        setStatus('Fetching EPG data...');
        localStorage.setItem('lastEPGSource', source);

        fetch(source)
          .then(res => {
            if (!res.ok) throw new Error('Failed to fetch EPG.');
            if (source.endsWith('.gz')) {
              return res.arrayBuffer();
            }
            return res.text();
          })
          .then(data => {
            let xmlText;
            if (source.endsWith('.gz')) {
              try {
                xmlText = pako.inflate(new Uint8Array(data), { to: 'string' });
              } catch (err) {
                throw new Error('Failed to decompress EPG data.');
              }
            } else {
              xmlText = data;
            }
            parseEPG(xmlText);
            setStatus('EPG loaded successfully.');
            applyFilters();
          })
          .catch(err => {
            console.error('EPG fetch error:', err);
            setStatus('Failed to fetch EPG.', true);
          });
      }
    }

    function parseEPG(xmlText) {
      epgData = { channels: [], programs: [] };
      const parser = new DOMParser();
      const xml = parser.parseFromString(xmlText, 'text/xml');

      const channelNodes = xml.getElementsByTagName('channel');
      for (let node of channelNodes) {
        const id = node.getAttribute('id');
        const nameNode = node.getElementsByTagName('display-name')[0];
        const name = nameNode ? nameNode.textContent : id;
        epgData.channels.push({ id, name });
      }

      const programmeNodes = xml.getElementsByTagName('programme');
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const tomorrow = new Date(today);
      tomorrow.setDate(tomorrow.getDate() + 1);

      for (let node of programmeNodes) {
        const start = new Date(node.getAttribute('start').replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})\s*([+-]\d{2})(\d{2})/, '$1-$2-$3T$4:$5:$6$7:$8'));
        const end = new Date(node.getAttribute('stop').replace(/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})\s*([+-]\d{2})(\d{2})/, '$1-$2-$3T$4:$5:$6$7:$8'));
        const channelId = node.getAttribute('channel');

        if (start >= today && start < tomorrow) {
          epgData.programs.push({
            channelId,
            start,
            end,
            title: node.getElementsByTagName('title')[0]?.textContent || 'No Title',
            description: node.getElementsByTagName('desc')[0]?.textContent || 'No description available.'
          });
        }
      }
    }

    function loadEPG() {
      if (!epgData.channels.length || !epgData.programs.length) {
        alert('Please fetch EPG data first.');
        return;
      }

      document.getElementById('tmdbContent').classList.remove('hidden');
      document.getElementById('tmdbTitle').textContent = 'Electronic Program Guide';
      const container = document.getElementById('tmdbSections');
      container.innerHTML = '';

      const div = document.createElement('div');
      div.className = 'bg-gray-100 p-4 rounded shadow';
      div.innerHTML = `
        <h3 class="text-lg font-bold mb-2">Now Playing</h3>
        <div id="epgGrid"></div>
      `;
      container.appendChild(div);

      renderEPGGrid();
    }

    function renderEPGGrid() {
      const grid = document.getElementById('epgGrid');
      grid.innerHTML = '';

      const currentTime = new Date();

      const headerRow = document.createElement('div');
      headerRow.className = 'epg-header';
      headerRow.style.gridColumn = '1';
      headerRow.textContent = 'Channel';
      grid.appendChild(headerRow);

      const spacerHeader = document.createElement('div');
      spacerHeader.className = 'epg-header';
      spacerHeader.style.gridColumn = '2';
      grid.appendChild(spacerHeader);

      const programHeader = document.createElement('div');
      programHeader.className = 'epg-header';
      programHeader.style.gridColumn = '3';
      programHeader.textContent = 'Now Playing';
      grid.appendChild(programHeader);

      epgData.channels.forEach((epgChannel, rowIndex) => {
        const nameLower = epgChannel.name.toLowerCase();
        const startsWithValidPrefix = /^(FR|UK|USA)/i.test(epgChannel.name);
        const isCanalPlus = nameLower.includes('canal+');
        const isBBC = nameLower.includes('bbc');
        if (!startsWithValidPrefix && !isCanalPlus && !isBBC) return;

        const playlistChannel = findMatchingChannel(epgChannel.name);
        if (!playlistChannel) return;

        const channelDiv = document.createElement('div');
        channelDiv.className = 'epg-channel';
        channelDiv.style.gridRow = rowIndex + 2;
        channelDiv.style.gridColumn = '1';
        channelDiv.textContent = playlistChannel.name.replace(/[\n\r]/g, '').trim();
        grid.appendChild(channelDiv);

        const spacerDiv = document.createElement('div');
        spacerDiv.className = 'epg-channel';
        spacerDiv.style.gridRow = rowIndex + 2;
        spacerDiv.style.gridColumn = '2';
        grid.appendChild(spacerDiv);

        const programs = epgData.programs.filter(p => p.channelId === epgChannel.id && currentTime >= p.start && currentTime < p.end);
        if (programs.length > 0) {
          const program = programs[0];
          const programDiv = document.createElement('div');
          programDiv.className = 'epg-program';
          programDiv.style.gridRow = rowIndex + 2;
          programDiv.style.gridColumn = '3';
          programDiv.innerHTML = `
            <span class="truncate flex-1">${program.title.replace(/[\n\r]/g, '').trim()}</span>
            <button onclick="playStream('${playlistChannel.url}', '${playlistChannel.name.replace(/[\n\r]/g, '')}')" class="text-blue-600">Play</button>
            <button onclick="copyToClipboard('${playlistChannel.url}')" class="text-green-600">Copy</button>
          `;
          grid.appendChild(programDiv);
        }
      });
    }

    const API_KEY = '729cf9f096e955020bb7d27c547be637';
    const BASE_URL = 'https://api.themoviedb.org/3';

    async function loadTMDB(type) {
      document.getElementById('tmdbContent').classList.remove('hidden');
      document.getElementById('tmdbTitle').textContent = type === 'movie' ? 'Movies' : 'Series';
      const sections = [
        { label: 'Trending', path: `/trending/${type}/week` },
        { label: 'Most Popular', path: `/${type}/popular` },
        { label: 'Highest Score', path: `/${type}/top_rated` }
      ];

      const container = document.getElementById('tmdbSections');
      container.innerHTML = '';

      for (const section of sections) {
        try {
          const res = await fetch(`${BASE_URL}${section.path}?api_key=${API_KEY}&language=en-US`);
          const json = await res.json();
          const items = json.results.slice(0, 6);

          const div = document.createElement('div');
          div.className = 'bg-gray-100 p-4 rounded shadow';
          div.innerHTML = `<h3 class="text-lg font-bold mb-2">${section.label}</h3>
            <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-2 text-xs">` +
            items.map(item => {
              const title = item.title || item.name;
              const matchType = type === 'tv' ? 'series' : type;
              const matches = findPlaylistMatches(title, matchType);
              let overlayContent = '';
              if (matches.length > 0) {
                overlayContent = matches.map(match => `
                  <div class="mb-2">
                    <div>${match.name} (${match.quality}${match.year ? ', ' + match.year : ''})</div>
                    <button onclick="playStream('${match.url}', '${match.name}')" class="text-blue-600">Play</button>
                    <button onclick="copyToClipboard('${match.url}')" class="text-green-600">Copy</button>
                  </div>
                `).join('');
              } else {
                overlayContent = '<div>Not in your playlist</div>';
              }
              return `
                <div class="thumbnail-container bg-white rounded shadow p-2">
                  <img src="https://image.tmdb.org/t/p/w300${item.poster_path}" class="w-full rounded mb-1" alt="${title}">
                  <div class="thumbnail-overlay">
                    <div class="overlay-content">${overlayContent}</div>
                  </div>
                  <div class="font-semibold truncate">${title}</div>
                  <div class="text-gray-600">⭐ ${item.vote_average}</div>
                </div>
              `;
            }).join('') +
          `</div>`;
          container.appendChild(div);
        } catch (err) {
          console.error(`TMDB fetch error: ${err}`);
        }
      }
    }

    function closeTMDB() {
      document.getElementById('tmdbContent').classList.add('hidden');
      document.getElementById('tmdbSections').innerHTML = '';
    }
  </script>
</body>
</html>
