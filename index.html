<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>IPTV Playlist Viewer</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
</head>
<body class="bg-gray-100 min-h-screen p-4">
  <div class="max-w-6xl mx-auto bg-white rounded-2xl shadow-md p-6">
    <h1 class="text-2xl font-bold mb-4 text-center">IPTV Playlist Viewer</h1>

    <!-- URL Input -->
    <div id="m3uForm" class="mb-4">
      <input type="text" id="m3uUrl" placeholder="Enter M3U URL" class="border p-2 w-full mb-2">
      <button class="bg-green-600 text-white px-4 py-2 rounded" onclick="fetchM3U()">Fetch Playlist</button>
    </div>

    <!-- Loader with Steps -->
    <div id="loader" class="text-center text-blue-500 font-semibold hidden mb-4">Fetching playlist...</div>

    <!-- Filters -->
    <div id="filters" class="hidden mb-4 space-y-2">
      <div class="grid grid-cols-1 sm:grid-cols-4 gap-2">
        <select id="languageFilter" class="p-2 border rounded" onchange="applyFilters()"></select>
        <select id="channelFilter" class="p-2 border rounded" onchange="applyFilters()"></select>
        <select id="qualityFilter" class="p-2 border rounded" onchange="applyFilters()"></select>
        <select id="yearFilter" class="p-2 border rounded" onchange="applyFilters()"></select>
      </div>
      <input type="text" id="search" placeholder="Search title..." class="p-2 border rounded w-full" oninput="applyFilters()">
    </div>

    <!-- Playlist Display -->
    <div id="playlistDisplay" class="space-y-4"></div>

    <!-- Video Player -->
    <div id="playerContainer" class="hidden fixed bottom-4 right-4 w-80 bg-black rounded shadow-lg">
      <video id="videoPlayer" controls class="w-full h-48 rounded"></video>
    </div>
  </div>

  <script>
    let allChannels = [];
    let favorites = new Set();

    async function fetchM3U() {
      const urlInput = document.getElementById('m3uUrl');
      let url = urlInput.value.trim();
      if (!url) return alert('Enter M3U URL');

      showStep('Connecting to server...');
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(HTTP error! Status: ${res.status});
        showStep('Fetching playlist...');
        const text = await res.text();

        if (!text.includes('#EXTINF')) throw new Error('Invalid playlist format');

        allChannels = parseM3U(text);
        localStorage.setItem('playlistUrl', url);
        showStep('Parsing and displaying...');
        updateFilterOptions();
        applyFilters();
        showStep('✅ Playlist loaded successfully');
        document.getElementById('filters').classList.remove('hidden');
      } catch (e) {
        console.error('Fetch failed:', e);
        showStep('❌ Fetch failed. Trying with proxy...', true);
        try {
          const proxiedUrl = 'https://corsproxy.io/?' + encodeURIComponent(url);
          const res = await fetch(proxiedUrl);
          if (!res.ok) throw new Error(Proxy error! Status: ${res.status});
          const text = await res.text();

          if (!text.includes('#EXTINF')) throw new Error('Invalid playlist format via proxy');

          allChannels = parseM3U(text);
          localStorage.setItem('playlistUrl', url);
          showStep('✅ Playlist loaded using proxy');
          updateFilterOptions();
          applyFilters();
          document.getElementById('filters').classList.remove('hidden');
        } catch (proxyError) {
          console.error('Proxy fetch failed:', proxyError);
          showStep('❌ Failed to load playlist even via proxy.', true);
        }
      }
    }

    function showStep(message, isError = false) {
      const loader = document.getElementById('loader');
      loader.textContent = message;
      loader.classList.remove('hidden');
      loader.classList.toggle('text-red-500', isError);
      loader.classList.toggle('text-blue-500', !isError);
    }

    function parseM3U(text) {
      const lines = text.split('\n');
      const channels = [];
      let current = {};
      for (let line of lines) {
        line = line.trim();
        if (line.startsWith('#EXTINF')) {
          const nameMatch = line.match(/,(.*)/);
          const groupMatch = line.match(/group-title="(.*?)"/i);
          current = {
            name: nameMatch ? nameMatch[1] : 'Unknown',
            group: groupMatch ? groupMatch[1] : 'Other',
            quality: getQuality(nameMatch ? nameMatch[1] : ''),
            language: getLanguage(nameMatch ? nameMatch[1] : ''),
            year: getYear(nameMatch ? nameMatch[1] : ''),
          };
        } else if (line && !line.startsWith('#')) {
          current.url = line;
          channels.push({ ...current });
        }
      }
      return channels;
    }

    function getQuality(name) {
      if (/UHD|4K/i.test(name)) return 'UHD';
      if (/FHD|1080p/i.test(name)) return 'FHD';
      if (/HD|720p/i.test(name)) return 'HD';
      if (/SD|480p/i.test(name)) return 'SD';
      return 'Unknown';
    }

    function getLanguage(name) {
      if (/\bFR\b|\bFRA\b|\bFrench\b/i.test(name)) return 'FR';
      if (/\bEN\b|\bENG\b|\bEnglish\b/i.test(name)) return 'EN';
      return 'Other';
    }

    function getYear(name) {
      const yearMatch = name.match(/\b(19|20)\d{2}\b/);
      return yearMatch ? yearMatch[0] : 'Unknown';
    }

    function updateFilterOptions() {
      const languageSet = new Set();
      const channelSet = new Set();
      const qualitySet = new Set();
      const yearSet = new Set();

      allChannels.forEach(c => {
        languageSet.add(c.language);
        channelSet.add(cleanChannelName(c.name));
        qualitySet.add(c.quality);
        yearSet.add(c.year);
      });

      populateSelect('languageFilter', Array.from(languageSet));
      populateSelect('channelFilter', Array.from(channelSet));
      populateSelect('qualityFilter', Array.from(qualitySet));
      populateSelect('yearFilter', Array.from(yearSet));
    }

    function populateSelect(id, values) {
      const select = document.getElementById(id);
      select.innerHTML = '<option value="all">All</option>' +
        values.sort().map(v => <option value="${v}">${v}</option>).join('');
    }

    function cleanChannelName(name) {
      return name.replace(/HD|FHD|UHD|4K|SD|\d{3,4}p/gi, '').trim();
    }

    function applyFilters() {
      const lang = document.getElementById('languageFilter').value;
      const chan = document.getElementById('channelFilter').value;
      const qual = document.getElementById('qualityFilter').value;
      const year = document.getElementById('yearFilter').value;
      const search = document.getElementById('search').value.toLowerCase();

      let filtered = allChannels.filter(c =>
        (lang === 'all' || c.language === lang) &&
        (chan === 'all' || cleanChannelName(c.name) === chan) &&
        (qual === 'all' || c.quality === qual) &&
        (year === 'all' || c.year === year) &&
        c.name.toLowerCase().includes(search)
      );

      renderPlaylist(filtered);
    }

    function renderPlaylist(channels) {
      const display = document.getElementById('playlistDisplay');
      display.innerHTML = '';
      channels.forEach(ch => {
        const div = document.createElement('div');
        div.className = 'flex justify-between items-center border-b py-1 text-sm';
        div.innerHTML = `
          <span>${ch.name}</span>
          <div class="flex gap-2">
            <button onclick="playStream('${ch.url}')" class="text-blue-600 text-xs">Play</button>
            <button onclick="toggleFavorite('${ch.name}')" class="text-yellow-500 text-xs">★</button>
          </div>
        `;
        display.appendChild(div);
      });
    }

    function playStream(url) {
      const player = document.getElementById('videoPlayer');
      const container = document.getElementById('playerContainer');
      container.classList.remove('hidden');
      if (Hls.isSupported()) {
        const hls = new Hls();
        hls.loadSource(url);
        hls.attachMedia(player);
      } else if (player.canPlayType('application/vnd.apple.mpegurl')) {
        player.src = url;
      }
      player.play();
    }

    function toggleFavorite(name) {
      if (favorites.has(name)) {
        favorites.delete(name);
      } else {
        favorites.add(name);
      }
      localStorage.setItem('favorites', JSON.stringify([...favorites]));
      applyFilters();
    }

    // On page load
    window.onload = () => {
      const savedUrl = localStorage.getItem('playlistUrl');
      const savedFavs = JSON.parse(localStorage.getItem('favorites') || '[]');
      favorites = new Set(savedFavs);
      if (savedUrl) {
        document.getElementById('m3uUrl').value = savedUrl;
        fetchM3U();
      }
    }
  </script>
</body>
</html>
